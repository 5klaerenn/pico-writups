# EVEN RSA CAN BE BROKEN???

## Description
This service provides you an encrypted flag. Can you decrypt it with just N & e?
The program's source code can be downloaded here.

## Writeup

flag: picoCTF{tw0_1$_pr!m37dbe6984}

Je télécharge le code source du programme.
C'est un script d'encryption RSA avec un N et un e. 
Ca me rappelle un challenge sur HuberHackin. 

Quand on lance le serveur du challenge, on obtient un N, un e et
un cyphertext : 

```
N: 19716334468285957418952539664270218974651096027540445607879746430407845831159523849215037436110628939687244095236811023517245171908992627550006563425241874
e: 65537
cyphertext: 2060644667361307714920337799557921322781169616488936442851448017357435833283882436966183663869774208367934373099271810010867394555989415859568017152174535
```

On sait que N est le modulus de la clé et que `N = p * q` avec p et q des
nombres premiers. 

Pour pouvoir déchiffrer le message, on a besoin de trouver p et q pour
pouvoir calculer d (la clé privée).

En faisant la décomposition des nombres premiers, on obtient :
`197163344682…874 =
2 × 9858167234142978709476269832135109487325548013770222803939873215203922915579761924607518718055314469843622047618405511758622585954496313775003281712620937`

On peut alors poser : `p = 2` et `q = 9858167234142978709476269832135109487325548013770222803939873215203922915579761924607518718055314469843622047618405511758622585954496313775003281712620937`

Pour le reste, on fait un petit script pour déchiffrer :

```python
from Crypto.Util.number import long_to_bytes, inverse

N = 19716334468285957418952539664270218974651096027540445607879746430407845831159523849215037436110628939687244095236811023517245171908992627550006563425241874
e = 65537
c = 2060644667361307714920337799557921322781169616488936442851448017357435833283882436966183663869774208367934373099271810010867394555989415859568017152174535

p = 2
q = 9858167234142978709476269832135109487325548013770222803939873215203922915579761924607518718055314469843622047618405511758622585954496313775003281712620937

phi = (p-1) * (q-1)
d = inverse(e, phi)

m = pow(c, d, N)

flag = long_to_bytes(m)
print(flag.decode())
```

Puis : 

```
 python3 decrypt.py
picoCTF{tw0_1$_pr!m37dbe6984}
```

Ca va encore prendre du travail pour avoir les automatismes
et bien comprendre comment fonctionnent les clés RSA mais on
va y arriver !
